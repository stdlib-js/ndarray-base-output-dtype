{"version":3,"file":"index.mjs","sources":["../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n/* eslint-disable id-length */\n\n'use strict';\n\n// MODULES //\n\nimport isFloatingPointDataType from '@stdlib/ndarray-base-assert-is-floating-point-data-type';\nimport isRealFloatingPointDataType from '@stdlib/ndarray-base-assert-is-real-floating-point-data-type';\nimport isComplexFloatingPointDataType from '@stdlib/ndarray-base-assert-is-complex-floating-point-data-type';\nimport isIntegerDataType from '@stdlib/ndarray-base-assert-is-integer-data-type';\nimport isSignedIntegerDataType from '@stdlib/ndarray-base-assert-is-signed-integer-data-type';\nimport isUnsignedIntegerDataType from '@stdlib/ndarray-base-assert-is-unsigned-integer-data-type';\nimport isRealDataType from '@stdlib/ndarray-base-assert-is-real-data-type';\nimport isNumericDataType from '@stdlib/ndarray-base-assert-is-numeric-data-type';\nimport isBooleanDataType from '@stdlib/ndarray-base-assert-is-boolean-data-type';\nimport isIntegerIndexDataType from '@stdlib/ndarray-base-assert-is-integer-index-data-type';\nimport isBooleanIndexDataType from '@stdlib/ndarray-base-assert-is-boolean-index-data-type';\nimport isMaskIndexDataType from '@stdlib/ndarray-base-assert-is-mask-index-data-type';\nimport isDataType from '@stdlib/ndarray-base-assert-is-data-type';\nimport { isPrimitive as isString } from '@stdlib/assert-is-string';\nimport promoteDataTypes from '@stdlib/ndarray-base-promote-dtypes';\nimport defaults from '@stdlib/ndarray-defaults';\nimport join from '@stdlib/array-base-join';\nimport format from '@stdlib/error-tools-fmtprodmsg';\n\n\n// VARIABLES //\n\nvar DEFAULT_DTYPE = defaults.get( 'dtypes.default' );\nvar DEFAULT_INDEX_DTYPE = defaults.get( 'dtypes.default_index' );\nvar DEFAULT_SIGNED_INTEGER_DTYPE = defaults.get( 'dtypes.signed_integer' );\nvar DEFAULT_UNSIGNED_INTEGER_DTYPE = defaults.get( 'dtypes.unsigned_integer' );\nvar DEFAULT_REAL_FLOATING_POINT_DTYPE = defaults.get( 'dtypes.real_floating_point' );\nvar DEFAULT_COMPLEX_FLOATING_POINT_DTYPE = defaults.get( 'dtypes.complex_floating_point' );\n\n// Table where, for each respective policy, the value is a function which applies the policy to an input data type...\nvar POLICY_TABLE1 = {\n\t'default': defaultPolicy,\n\t'default_index': defaultIndexPolicy,\n\t'same': samePolicy,\n\t'promoted': promotedPolicy,\n\t'accumulation': accumulationPolicy\n};\n\n// Table where, for each respective policy, the value is an array whose first element is an assertion and whose second element is a fallback data type...\nvar POLICY_TABLE2 = {\n\t// Floating-point policies...\n\t'floating_point': [\n\t\tisFloatingPointDataType,\n\t\tdefaults.get( 'dtypes.floating_point' )\n\t],\n\t'floating_point_and_generic': [\n\t\twrap( isFloatingPointDataType ),\n\t\tdefaults.get( 'dtypes.floating_point' )\n\t],\n\t'real_floating_point': [\n\t\tisRealFloatingPointDataType,\n\t\tresolveDefaultRealFloatingPoint\n\t],\n\t'real_floating_point_and_generic': [\n\t\twrap( isRealFloatingPointDataType ),\n\t\tresolveDefaultRealFloatingPoint\n\t],\n\t'complex_floating_point': [\n\t\tisComplexFloatingPointDataType,\n\t\tresolveDefaultComplexFloatingPoint\n\t],\n\t'complex_floating_point_and_generic': [\n\t\twrap( isComplexFloatingPointDataType ),\n\t\tresolveDefaultComplexFloatingPoint\n\t],\n\n\t// Integer policies...\n\t'integer': [\n\t\tisIntegerDataType,\n\t\tdefaults.get( 'dtypes.integer' )\n\t],\n\t'integer_and_generic': [\n\t\twrap( isIntegerDataType ),\n\t\tdefaults.get( 'dtypes.integer' )\n\t],\n\t'signed_integer': [\n\t\tisSignedIntegerDataType,\n\t\tDEFAULT_SIGNED_INTEGER_DTYPE\n\t],\n\t'signed_integer_and_generic': [\n\t\twrap( isSignedIntegerDataType ),\n\t\tDEFAULT_SIGNED_INTEGER_DTYPE\n\t],\n\t'unsigned_integer': [\n\t\tisUnsignedIntegerDataType,\n\t\tDEFAULT_UNSIGNED_INTEGER_DTYPE\n\t],\n\t'unsigned_integer_and_generic': [\n\t\twrap( isUnsignedIntegerDataType ),\n\t\tDEFAULT_UNSIGNED_INTEGER_DTYPE\n\t],\n\n\t// Real-valued number policies...\n\t'real': [\n\t\tisRealDataType,\n\t\tdefaults.get( 'dtypes.real' )\n\t],\n\t'real_and_generic': [\n\t\twrap( isRealDataType ),\n\t\tdefaults.get( 'dtypes.real' )\n\t],\n\n\t// Real- and complex-valued number policies...\n\t'numeric': [\n\t\tisNumericDataType,\n\t\tdefaults.get( 'dtypes.numeric' )\n\t],\n\t'numeric_and_generic': [\n\t\twrap( isNumericDataType ),\n\t\tdefaults.get( 'dtypes.numeric' )\n\t],\n\n\t// Boolean policies...\n\t'boolean': [\n\t\tisBooleanDataType,\n\t\tdefaults.get( 'dtypes.boolean' )\n\t],\n\t'boolean_and_generic': [\n\t\twrap( isBooleanDataType ),\n\t\tdefaults.get( 'dtypes.boolean' )\n\t],\n\n\t// Index policies...\n\t'integer_index': [\n\t\tisIntegerIndexDataType,\n\t\tdefaults.get( 'dtypes.integer_index' )\n\t],\n\t'integer_index_and_generic': [\n\t\twrap( isIntegerIndexDataType ),\n\t\tdefaults.get( 'dtypes.integer_index' )\n\t],\n\t'boolean_index': [\n\t\tisBooleanIndexDataType,\n\t\tdefaults.get( 'dtypes.boolean_index' )\n\t],\n\t'boolean_index_and_generic': [\n\t\twrap( isBooleanIndexDataType ),\n\t\tdefaults.get( 'dtypes.boolean_index' )\n\t],\n\t'mask_index': [\n\t\tisMaskIndexDataType,\n\t\tdefaults.get( 'dtypes.mask_index' )\n\t],\n\t'mask_index_and_generic': [\n\t\twrap( isMaskIndexDataType ),\n\t\tdefaults.get( 'dtypes.mask_index' )\n\t]\n};\n\n// Table mapping complex-valued floating-point data types to real-valued floating-point data types having the same precision:\nvar COMPLEX2FLOAT = {\n\t'complex128': 'float64',\n\t'complex64': 'float32',\n\t'complex32': 'float16'\n};\n\n// Table mapping real-valued floating-point data types to complex-valued floating-point data types having the same precision:\nvar FLOAT2COMPLEX = {\n\t'float64': 'complex128',\n\t'float32': 'complex64',\n\t'float16': 'complex32'\n};\n\n\n// FUNCTIONS //\n\n/**\n* Wraps a data type validation function to also check for a \"generic\" data type.\n*\n* @private\n* @param {Function} fcn - validation function\n* @returns {Function} wrapped validation function\n*/\nfunction wrap( fcn ) {\n\treturn wrapper;\n\n\t/**\n\t* Tests whether a provided data type is either \"generic\" or satisfies a data type validation function.\n\t*\n\t* @private\n\t* @param {*} value - input value\n\t* @returns {boolean} boolean indicating whether a provided value passes a test\n\t*/\n\tfunction wrapper( value ) {\n\t\treturn ( value === 'generic' ) || fcn( value );\n\t}\n}\n\n/**\n* Returns the default data type.\n*\n* @private\n* @returns {string} output ndarray data type\n*/\nfunction defaultPolicy() {\n\t// When the policy is \"default\", the output data type should always be the default data type without consideration for the input data types:\n\treturn DEFAULT_DTYPE;\n}\n\n/**\n* Returns the default index data type.\n*\n* @private\n* @returns {string} output ndarray data type\n*/\nfunction defaultIndexPolicy() {\n\t// When the policy is \"default_index\", the output data type should always be the default index data type without consideration for the input data types:\n\treturn DEFAULT_INDEX_DTYPE;\n}\n\n/**\n* Applies the \"same\" policy by returning the common input data type.\n*\n* @private\n* @param {StringArray} dtypes - input ndarray data types\n* @throws {Error} invalid data types\n* @returns {string} output ndarray data type\n*/\nfunction samePolicy( dtypes ) {\n\tvar dt;\n\tvar i;\n\n\tdt = dtypes[ 0 ];\n\tfor ( i = 1; i < dtypes.length; i++ ) {\n\t\t// When the policy is \"same\", we require that all data types (both input and output) be the same...\n\t\tif ( dtypes[ i ] !== dt ) {\n\t\t\tthrow new Error( format( 'invalid argument. Unable to resolve an output data type. The output data type policy is \"same\" and yet the input data types are not equal. Data types: [%s].', join( dtypes, ', ' ) ) );\n\t\t}\n\t}\n\treturn dt;\n}\n\n/**\n* Applies the \"promoted\" policy by applying type promotion to the list of provided data types.\n*\n* @private\n* @param {StringArray} dtypes - input ndarray data types\n* @throws {Error} must provide data types which can be safely cast to a common data type\n* @returns {string} output ndarray data type\n*/\nfunction promotedPolicy( dtypes ) {\n\tvar dt = promoteDataTypes( dtypes );\n\tif ( dt === null ) {\n\t\tthrow new Error( format( 'invalid argument. Unable to apply type promotion rules when resolving a data type to which the input data types can be safely cast. Data types: [%s].', join( dtypes, ', ' ) ) );\n\t}\n\treturn dt;\n}\n\n/**\n* Applies the \"accumulation\" policy to the list of input data types.\n*\n* @private\n* @param {StringArray} dtypes - input ndarray data types\n* @throws {Error} must provide data types which can be safely cast to a common data type\n* @returns {string} output ndarray data type\n*/\nfunction accumulationPolicy( dtypes ) {\n\tvar dt = promotedPolicy( dtypes );\n\n\t// If the promoted data type is floating-point, allow accumulation in that data type as overflow/underflow is handled naturally as a built-in feature of that data type...\n\tif ( isFloatingPointDataType( dt ) || dt === 'generic' ) { // NOTE: we may want to revisit this in the future for float16/complex32, where the value range is much more limited\n\t\treturn dt;\n\t}\n\t// Unless the promoted data type value range is larger than the default un/signed integer data type, accumulate in the default un/signed integer data type, as accumulating in small range integer data types (e.g., `int8`) is at high risk for overflow, especially for ndarrays containing many elements...\n\tif ( isUnsignedIntegerDataType( dt ) ) {\n\t\treturn promoteDataTypes( [ dt, DEFAULT_UNSIGNED_INTEGER_DTYPE ] );\n\t}\n\tif ( isSignedIntegerDataType( dt ) ) {\n\t\treturn promoteDataTypes( [ dt, DEFAULT_SIGNED_INTEGER_DTYPE ] );\n\t}\n\t// For all other data types, accumulate in the default real-valued floating-point data type...\n\treturn DEFAULT_REAL_FLOATING_POINT_DTYPE;\n}\n\n/**\n* Resolves a default real-valued floating-point data type which preserves floating-point precision.\n*\n* @private\n* @param {string} dtype - input ndarray data type\n* @returns {string} output ndarray data type\n*/\nfunction resolveDefaultRealFloatingPoint( dtype ) {\n\treturn COMPLEX2FLOAT[ dtype ] || DEFAULT_REAL_FLOATING_POINT_DTYPE;\n}\n\n/**\n* Resolves a default complex-valued floating-point data type which preserves floating-point precision.\n*\n* @private\n* @param {string} dtype - input ndarray data type\n* @returns {string} output ndarray data type\n*/\nfunction resolveDefaultComplexFloatingPoint( dtype ) {\n\treturn FLOAT2COMPLEX[ dtype ] || DEFAULT_COMPLEX_FLOATING_POINT_DTYPE;\n}\n\n\n// MAIN //\n\n/**\n* Resolves the output data type from a list of input ndarray data types.\n*\n* @param {StringArray} dtypes - list of input ndarray data types\n* @param {string} policy - output ndarray data type policy\n* @throws {TypeError} second argument must be a recognized data type policy\n* @throws {Error} unexpected error\n* @returns {string} output ndarray data type\n*\n* @example\n* var dt = resolve( [ 'float64' ], 'complex_floating_point' );\n* // returns <string>\n*/\nfunction resolve( dtypes, policy ) {\n\tvar dt;\n\tvar p;\n\n\t// First, check whether the policy mandates that the output data type always be a specific data type...\n\tif ( isDataType( policy ) ) {\n\t\treturn policy;\n\t}\n\t// Next, check whether the policy is one in which we may be able to avoid type promotion...\n\tp = POLICY_TABLE1[ policy ];\n\tif ( p !== void 0 ) {\n\t\treturn p( dtypes );\n\t}\n\t// For all other policies, we always apply type promotion rules...\n\tdt = promotedPolicy( dtypes );\n\n\t// Check whether the policy requires determining the data type \"kind\"...\n\tp = POLICY_TABLE2[ policy ];\n\tif ( p !== void 0 ) {\n\t\t// Check whether the promoted data type belongs to the data type \"kind\"...\n\t\tif ( p[ 0 ]( dt ) ) {\n\t\t\t// If so, we can just return the promoted data type:\n\t\t\treturn dt;\n\t\t}\n\t\t// Otherwise, we need to fallback to a default data type belonging to that \"kind\"...\n\t\tif ( isString( p[ 1 ] ) ) {\n\t\t\treturn p[ 1 ];\n\t\t}\n\t\treturn p[ 1 ]( dt );\n\t}\n\tthrow new TypeError( format( 'nullDw', policy ) );\n}\n\n\n// EXPORTS //\n\nexport default resolve;\n"],"names":["DEFAULT_DTYPE","defaults","get","DEFAULT_INDEX_DTYPE","DEFAULT_SIGNED_INTEGER_DTYPE","DEFAULT_UNSIGNED_INTEGER_DTYPE","DEFAULT_REAL_FLOATING_POINT_DTYPE","DEFAULT_COMPLEX_FLOATING_POINT_DTYPE","POLICY_TABLE1","default","default_index","same","dtypes","dt","i","length","Error","format","join","promoted","promotedPolicy","accumulation","isFloatingPointDataType","isUnsignedIntegerDataType","promoteDataTypes","isSignedIntegerDataType","POLICY_TABLE2","floating_point","floating_point_and_generic","wrap","real_floating_point","isRealFloatingPointDataType","resolveDefaultRealFloatingPoint","real_floating_point_and_generic","complex_floating_point","isComplexFloatingPointDataType","resolveDefaultComplexFloatingPoint","complex_floating_point_and_generic","integer","isIntegerDataType","integer_and_generic","signed_integer","signed_integer_and_generic","unsigned_integer","unsigned_integer_and_generic","real","isRealDataType","real_and_generic","numeric","isNumericDataType","numeric_and_generic","boolean","isBooleanDataType","boolean_and_generic","integer_index","isIntegerIndexDataType","integer_index_and_generic","boolean_index","isBooleanIndexDataType","boolean_index_and_generic","mask_index","isMaskIndexDataType","mask_index_and_generic","COMPLEX2FLOAT","complex128","complex64","complex32","FLOAT2COMPLEX","float64","float32","float16","fcn","value","dtype","resolve","policy","p","isDataType","isString","TypeError"],"mappings":";;m/DA8CA,IAAIA,EAAgBC,EAASC,IAAK,kBAC9BC,EAAsBF,EAASC,IAAK,wBACpCE,EAA+BH,EAASC,IAAK,yBAC7CG,EAAiCJ,EAASC,IAAK,2BAC/CI,EAAoCL,EAASC,IAAK,8BAClDK,EAAuCN,EAASC,IAAK,iCAGrDM,EAAgB,CACnBC,QAmKD,WAEC,OAAOT,CACR,EArKCU,cA6KD,WAEC,OAAOP,CACR,EA/KCQ,KAyLD,SAAqBC,GACpB,IAAIC,EACAC,EAGJ,IADAD,EAAKD,EAAQ,GACPE,EAAI,EAAGA,EAAIF,EAAOG,OAAQD,IAE/B,GAAKF,EAAQE,KAAQD,EACpB,MAAM,IAAIG,MAAOC,EAAQ,+JAAgKC,EAAMN,EAAQ,QAGzM,OAAOC,CACR,EApMCM,SAAYC,EACZC,aA6ND,SAA6BT,GAC5B,IAAIC,EAAKO,EAAgBR,GAGzB,GAAKU,EAAyBT,IAAe,YAAPA,EACrC,OAAOA,EAGR,GAAKU,EAA2BV,GAC/B,OAAOW,EAAkB,CAAEX,EAAIR,IAEhC,GAAKoB,EAAyBZ,GAC7B,OAAOW,EAAkB,CAAEX,EAAIT,IAGhC,OAAOE,CACR,GAzOIoB,EAAgB,CAEnBC,eAAkB,CACjBL,EACArB,EAASC,IAAK,0BAEf0B,2BAA8B,CAC7BC,EAAMP,GACNrB,EAASC,IAAK,0BAEf4B,oBAAuB,CACtBC,EACAC,GAEDC,gCAAmC,CAClCJ,EAAME,GACNC,GAEDE,uBAA0B,CACzBC,EACAC,GAEDC,mCAAsC,CACrCR,EAAMM,GACNC,GAIDE,QAAW,CACVC,EACAtC,EAASC,IAAK,mBAEfsC,oBAAuB,CACtBX,EAAMU,GACNtC,EAASC,IAAK,mBAEfuC,eAAkB,CACjBhB,EACArB,GAEDsC,2BAA8B,CAC7Bb,EAAMJ,GACNrB,GAEDuC,iBAAoB,CACnBpB,EACAlB,GAEDuC,6BAAgC,CAC/Bf,EAAMN,GACNlB,GAIDwC,KAAQ,CACPC,EACA7C,EAASC,IAAK,gBAEf6C,iBAAoB,CACnBlB,EAAMiB,GACN7C,EAASC,IAAK,gBAIf8C,QAAW,CACVC,EACAhD,EAASC,IAAK,mBAEfgD,oBAAuB,CACtBrB,EAAMoB,GACNhD,EAASC,IAAK,mBAIfiD,QAAW,CACVC,EACAnD,EAASC,IAAK,mBAEfmD,oBAAuB,CACtBxB,EAAMuB,GACNnD,EAASC,IAAK,mBAIfoD,cAAiB,CAChBC,EACAtD,EAASC,IAAK,yBAEfsD,0BAA6B,CAC5B3B,EAAM0B,GACNtD,EAASC,IAAK,yBAEfuD,cAAiB,CAChBC,EACAzD,EAASC,IAAK,yBAEfyD,0BAA6B,CAC5B9B,EAAM6B,GACNzD,EAASC,IAAK,yBAEf0D,WAAc,CACbC,EACA5D,EAASC,IAAK,sBAEf4D,uBAA0B,CACzBjC,EAAMgC,GACN5D,EAASC,IAAK,uBAKZ6D,EAAgB,CACnBC,WAAc,UACdC,UAAa,UACbC,UAAa,WAIVC,EAAgB,CACnBC,QAAW,aACXC,QAAW,YACXC,QAAW,aAaZ,SAASzC,EAAM0C,GACd,OASA,SAAkBC,GACjB,MAAmB,YAAVA,GAAyBD,EAAKC,EACvC,CACF,CAsDA,SAASpD,EAAgBR,GACxB,IAAIC,EAAKW,EAAkBZ,GAC3B,GAAY,OAAPC,EACJ,MAAM,IAAIG,MAAOC,EAAQ,wJAAyJC,EAAMN,EAAQ,QAEjM,OAAOC,CACR,CAmCA,SAASmB,EAAiCyC,GACzC,OAAOV,EAAeU,IAAWnE,CAClC,CASA,SAAS8B,EAAoCqC,GAC5C,OAAON,EAAeM,IAAWlE,CAClC,CAkBA,SAASmE,EAAS9D,EAAQ+D,GACzB,IAAI9D,EACA+D,EAGJ,GAAKC,EAAYF,GAChB,OAAOA,EAIR,QAAW,KADXC,EAAIpE,EAAemE,IAElB,OAAOC,EAAGhE,GAOX,GAJAC,EAAKO,EAAgBR,QAIV,KADXgE,EAAIlD,EAAeiD,IAGlB,OAAKC,EAAG,GAAK/D,GAELA,EAGHiE,EAAUF,EAAG,IACVA,EAAG,GAEJA,EAAG,GAAK/D,GAEhB,MAAM,IAAIkE,UAAW9D,EAAQ,SAAU0D,GACxC"}